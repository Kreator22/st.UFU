//Лабораторная работа #2, блок задач 3 - циклы
//https://edu.mmcs.sfedu.ru/mod/assign/view.php?id=18888

/*
1.Даны целые числа A и B (A < B).
Вывести в порядке возрастания все целые числа, расположенные между A и B
(не включая сами числа A и B), а также количество N этих чисел.

2. Дано целое число N > 0. Найти сумму
1 + 1/2 + 1/3 + ... + 1/N
Проверьте правильность вашей программы не менее чем на двух наборах данных.
Обязательно проверьте случай N = 1.

3. Даны целые числа A и B (A ≤ B). 
Найти произведение всех целых чисел от A до B включительно.

4. Дано вещественное число X и целое число N > 0. Найти значение выражения
1 + x + x^2 / 2! + x^3 / 3! + ... + x^N / N!

5. Даны положительные числа A и B (A ≥ B). 
На отрезке длины A размещено максимально возможное количество отрезков длины B (без наложений). 
Не используя операции умножения и деления, найти длину незанятой части отрезка A.

6. Дано целое число N ≥ 1. 
Последовательность Fk чисел Фибоначчи определяется следующим образом:
F1 = 1,F2 = 1,Fk = Fk−2 + Fk−1, где k = 3,4,…
Вывести элементы F1, F2, …, FN.
Указание. Для вычисления чисел Фибоначчи разрешается использовать не более трёх переменных.

7 Даны целые положительные числа N и K. 
Используя только операции сложения и вычитания, найти частное от деления нацело N на K, 
а также остаток от этого деления.

8. Проверить, является ли заданное целое положительное число степенью тройки.

9. Дано целое число. Найти количество его цифр и их сумму.

10. Дано положительное целое число. Вывести его запись в двоичной системе счисления.
*/

using System.Diagnostics.CodeAnalysis;
using System.Numerics;
using System.Runtime.CompilerServices;

namespace Lab_02_03
{
    public class Lab_02_03
    {
        /// <summary>
        /// 1.Даны целые числа A и B (A &lt; B).
        /// Вывести в порядке возрастания все целые числа, расположенные между A и B
        /// (не включая сами числа A и B), а также количество N этих чисел.
        /// </summary>
        /// <remarks>
        /// Моё решение так же поддерживает случаи A = B и A &gt; B.<br/> 
        /// Так же работает с отрицательными числами.
        /// </remarks>
        public static (IEnumerable<int>, int n) Lab_02_03_01(int a, int b)
        {
            int n = Math.Abs(a - b);
            if (n > 0) n--;

            return (Generator(a + 1, b), n);

            static IEnumerable<int> Generator(int min, int max)
            {
                for(int i = min; i < max; i++)
                    yield return i;
            }
        }

        /// <summary>
        /// 2. Дано целое число N > 0. Найти сумму
        /// 1 + 1/2 + 1/3 + ... + 1/N
        /// Проверьте правильность вашей программы не менее чем на двух наборах данных.
        /// Обязательно проверьте случай N = 1.
        /// </summary>
        public static double Lab_02_03_02(int n)
        {
            double result = 0;

            while(n > 0)
            {
                result += 1.0 / n;
                n--;
            }

            return result;
        }

        /// <summary>
        /// 3. Даны целые числа A и B (A ≤ B). 
        /// Найти произведение всех целых чисел от A до B включительно.
        /// </summary>
        public static int Lab_02_03_03(int a, int b)
        {
            int result = 1;

            while (a <= b)
            {
                result *= a;
                a++;
            }

            return result;
        }

        /// <summary>
        /// 4. Дано вещественное число X и целое число N &gt; 0.<br/>
        /// Найти значение выражения<br/>
        /// 1 + x + x^2 / 2! + x^3 / 3! + ... + x^N / N!
        /// </summary>
        /// <remarks>
        /// Ряд Маклорена - частный случай разложения в ряд Тейлора в нулевой точке.
        /// В задаче ряд для разложения e^x, 
        /// где N - количество членов ряда (точность разложения)
        /// </remarks>
        /// <param name="x">Степень</param>
        /// <param name="n">Количество членов ряда (точность разложения)</param>
        public static double Lab_02_03_04(double x, uint n)
        {
            // Первое решение, не работает для n > 20,
            // начинаются переполнения переменных.
            // Перейти к BigInteger тоже не получается, 
            // т.к. потом проблема их поделить друг на друга 
            // и получить число с плавающей запятой с нормальной точностью.
            /*double result = 1 + x;

            for (int i = 2; i < n; i++)
                result += Math.Pow(x, i) / Factorial(i);            
            
            static long Factorial(int n) => 
                n == 0 ? 1 : n * Factorial(n - 1);*/
            
            double result = 1 + x;

            //   1 + x + x^2 / 2! + x^3 / 3! + ... + x^N / N! =
            // = 1 + x +  term_2  +  term_3  + ... +  term_N
            for (int N = 2; N <= n; N++)
            {
                double term_N = 1;

                //x^N / N! = ( X * X * X * ... ) / ( 1 * 2 * 3 * ... )
                for (int i = 1; i <= N; i++) 
                    term_N = term_N * x / i;

                result += term_N;
            } 
                return result;
        }
    }
}