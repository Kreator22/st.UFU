//Домашнее задание #3, блок заданий 1 - Сортировка
//https://edu.mmcs.sfedu.ru/mod/assign/view.php?id=18931

//Блок заданий 2 (замер производительности метода, делегаты) выполнен в юнит тестах

/*
 * 1. Сортировка пузырьком. Дан массив A размера N. 
 * Упорядочить его по возрастанию методом сортировки простым обменом («пузырьковой» сортировкой): 
 * просматривать массив, сравнивая его соседние элементы 
 * (a[0] и a[1], a[1] и a[2] и т. д.) и меняя их местами, 
 * если левый элемент пары больше правого; 
 * повторить описанные действия N − 1 раз или до тех пор, пока на очередном проходе не окажется, 
 * что обмены больше не нужны, что означает - массив отсортирован. 
 * Учесть, что при каждом просмотре количество анализируемых пар можно уменьшить на 1.
 * Указание 1. В задаче удобно использовать метод Swap(ref int a, ref int b) из лабораторной работы №1.
 * Указание 2. Все методы сортировки принимают в качестве параметра массив целых чисел (и только его).
 * 
 * 2. Сортировка выбором. Дан массив размера N. 
 * Упорядочить его по возрастанию методом сортировки выбором: 
 * найти максимальный элемент массива и поменять его местами с последним (N-1) элементом; 
 * выполнить описанные действия N − 1 раз, каждый раз уменьшая на 1 количество анализируемых элементов.
 * Указание 1 В задаче удобно использовать метод Swap(ref int a, ref int b) из лабораторной работы №1.
 * Указание 2 Создайте вспомогательный метод static int MaxIdx(int[] array, int n), 
 * который возвращает индекс наибольшего элемента, индекс которого меньше n
 * 
 * 3. Сортировка выбором. Дан массив размера N. 
 * Упорядочить его по возрастанию методом сортировки выбором: 
 * найти минимальный элемент массива и поменять его местами с первым элементом 
 * в неотсортированной части массива; выполнить описанные действия N − 1 раз, 
 * каждый раз уменьшая на 1 количество анализируемых элементов.
 * Указание Создайте вспомогательный метод static int MinIdx(int[] array, int n), 
 * который возвращает индекс наибольшего элемента, индекс которого больше n
 * Создать вспомогательный метод static void MakeItSorted(int[] array, int n) 
 * 
 * 4. Дан массив, элементы которого с нулевого по элемент с индексом n-1, 
 * упорядочены по возрастанию, а элемент с индексом n нарушает упорядоченность. 
 * Сделать массив упорядоченным, переместив n-й элемент на новую позицию
 * Указание В задаче удобно использовать метод Swap(ref int a, ref int b) в цикле.
 * 
 * 5. Сортировка вставками. 
 * Дан массив A размера N. Упорядочить его по возрастанию методом сортировки вставками:
 * Массив, состоящий из одного элемента - упорядоченный.
 * Рассмотрим первые два элемента массива и поменяем их местами таким образом, 
 * чтобы первые два элемента были упорядочены.
 * Предположим, что n-1 элементов массива упорядочены. 
 * Переместим n-й элемент массива таким образом, чтобы n элементов массива 
 * образовывали упорядоченную последовательность.
 * Реализуем алгоритм при помощи одного цикла, на каждой итерации которого 
 * происходит вызов метода MakeItSorted
 * 
 * 
 * Продемонстрируйте в методе Main() работу каждого из методов сортировки.
 * 
 */

namespace HW_03
{
    public class HW_03_01
    {
        /// <summary>
        /// 1. Сортировка пузырьком.
        /// </summary>
        public static void BubbleSort(ref int[] arr)
        {
            for(int i = 0; i < arr.Length; i++)
                for(int j = 0; j < arr.Length - i - 1; j++)
                {
                    if (arr[j] > arr[j + 1])
                        (arr[j], arr[j + 1]) = (arr[j + 1], arr[j]);
                }
        }

        /// <summary>
        /// 2. Сортировка выбором через поиск максимального
        /// </summary>
        public static void SelectionSortMax(ref int[] arr)
        {
            (int value, int n) max;
            int length = arr.Length;

            for(int i = 0; i < length - 1; i++)
            {
                max = (int.MinValue, 0);
                int j;

                for (j = 0; j < length - 1 - i; j++)
                {
                    if (arr[j] > max.value)
                        max = (arr[j], j);
                }

                if (max.value > arr[j])
                    (arr[max.n], arr[j]) = (arr[j], arr[max.n]);
            }     
        }

        /// <summary>
        /// 3. Сортировка выбором через поиск минимального
        /// </summary>
        public static void SelectionSortMin(ref int[] arr)
        {
            (int value, int n) min;
            int length = arr.Length;

            for (int i = 0; i < length - 1; i++)
            {
                min = (int.MaxValue, 0);
                int j;

                for (j = length - 1; j > i; j--)
                {
                    if (arr[j] < min.value)
                        min = (arr[j], j);
                }

                if (min.value < arr[j])
                    (arr[min.n], arr[j]) = (arr[j], arr[min.n]);
            }
        }

        /// <summary>
        /// 4. Дан массив, элементы которого с нулевого по элемент с индексом n-1, 
        /// упорядочены по возрастанию, а элемент с индексом n нарушает упорядоченность. <br/>
        /// Сделать массив упорядоченным, переместив n-й элемент на новую позицию
        /// </summary>
        public static void MakeItSorted(ref int[] arr)
        {
            //Значение элемента n
            int last = arr[arr.Length - 1];

            for (int i = arr.Length - 2; i >= 0 ; i--)
            {
                if (arr[i] > last)
                {
                    arr[i + 1] = arr[i];
                    if (i == 0) 
                        arr[0] = last;
                } 
                else
                {
                    arr[i + 1] = last;
                    break;
                }
            }
        }

        /// <summary>
        /// 5. Сортировка вставками <br/>
        /// Реализуем алгоритм при помощи одного цикла, на каждой итерации 
        /// которого происходит вызов метода MakeItSorted
        /// </summary>
        public static void InsertSort(ref int[] arr)
        {
            for(int i = 1; i <= arr.Length - 1; i++)
            {
                int[] tmp = new int[i + 1];
                Array.Copy(arr, tmp, i + 1);
                MakeItSorted(ref tmp);
                Array.Copy(tmp, arr, i + 1);
            }
        }
    }
}
